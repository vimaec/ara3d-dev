<#@ template language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
// AUTOGENERATED FILE: Do not edit directly, instead edit MathOps.tt

// MIT License 
// Copyright (C) 2019 Ara 3D. Inc
// https://ara3d.com
// This file is subject to the terms and conditions defined in
// file 'LICENSE.txt', which is part of this source code package.

<# 
var intTypes = new[] { "int", "long" };
var floatTypes = new[] { "float", "double" };
var nonVectorTypes = intTypes.Concat(floatTypes);
var comparableTypes = nonVectorTypes;
var vectorTypes = new[] { "Vector2", "Vector3", "Vector4", "DVector2", "DVector3", "DVector4" };
var floatAndVectorTypes = floatTypes.Concat(vectorTypes);
var types = nonVectorTypes.Concat(vectorTypes);
var araBinaryOps = new[] { "Add", "Subtract", "Multiply", "Divide" };
var araCompOps = new[] { "Gt", "Lt", "GtEq", "LtEq", "Eq", "NEq" };
var sysBinaryOps = new[] { "Atan2", "Log", "Pow" };
var araUnaryOps = new[] { "Inverse", "Ceiling", "Floor", "Round", "Truncate", "Sqr", "Cube" };
var sysUnaryOps = new[] { "Abs", "Acos", "Asin", "Atan", "Cos", "Cosh", "Exp", "Log", "Log10", "Sin", "Sinh", "Sqrt", "Tan", "Tanh" };
var allUnaryOps = sysUnaryOps.Concat(araUnaryOps);
#>
using System;
using System.Runtime.CompilerServices;

namespace Ara3D 
{
	public static partial class MathOps 
	{
<# 
foreach (var op in sysUnaryOps) { 
#>
		public static double <#= op #>(this double x) => Math.<#= op #>(x);
<# } #>

<# 
foreach (var op in sysUnaryOps) { 
#>
		public static float <#= op #>(this float x) => (float)Math.<#= op #>(x);
<# } #>

<# 
foreach (var t in floatTypes) { 
#>
		public static <#= t #> Inverse (this <#= t #> x) => (<#= t #>)1 / x; 		
		public static <#= t #> Truncate (this <#= t #> x) => (<#= t #>)Math.Truncate(x); 
		public static <#= t #> Ceiling (this <#= t #> x) => (<#= t #>)Math.Ceiling(x); 
		public static <#= t #> Floor (this <#= t #> x) => (<#= t #>)Math.Floor(x);
		public static <#= t #> Round (this <#= t #> x) => (<#= t #>)System.Math.Round(x); 
		public static <#= t #> ToRadians(this <#= t #> x) => (<#= t #>)(x * Constants.DegreesToRadians);
		public static <#= t #> ToDegrees(this <#= t #> x) => (<#= t #>)(x * Constants.RadiansToDegrees);
		public static <#= t #> Distance(this <#= t #> v1, <#= t #> v2) => (v1 - v2).Abs();
		public static bool IsInfinity(this <#= t #> v) => <#= t #>.IsInfinity(v);
		public static bool IsNaN(this <#= t #> v) => <#= t #>.IsNaN(v);
		public static bool AlmostEquals(this <#= t #> v1, <#= t #> v2) => (v2 - v1).AlmostZero();
		public static bool AlmostZero(this <#= t #> v, float tolerance = Constants.Tolerance) => v.Abs() < tolerance;
<# } #>

<# 
foreach (var t in types) { 
#>
        public static <#= t #> Add (this <#= t #> v1, <#= t #> v2) => v1 + v2;
        public static <#= t #> Subtract (this <#= t #> v1, <#= t #> v2) => v1 - v2;
        public static <#= t #> Multiply (this <#= t #> v1, <#= t #> v2) => v1 * v2;
        public static <#= t #> Divide (this <#= t #> v1, <#= t #> v2) => v1 / v2;
		public static <#= t #> Negate (this <#= t #> v) => -v; 
<# } #>

<#
foreach (var t in nonVectorTypes) { 
#>
		public static bool WithinInterval(this <#= t #> v, <#= t #> min, <#= t #> max) => v >= min && v <= max;
		public static <#= t #> Sqr (this <#= t #> x) => x * x;
		public static <#= t #> Cube (this <#= t #> x) => x * x * x; 
        public static <#= t #> Min (this <#= t #> v1, <#= t #> v2) => Math.Min(v1, v2);
        public static <#= t #> Max (this <#= t #> v1, <#= t #> v2) => Math.Max(v1, v2); 
<# } #>

<#
foreach (var t in comparableTypes) { 
#>
        public static bool Gt (this <#= t #> v1, <#= t #> v2) => v1 > v2; 
        public static bool Lt (this <#= t #> v1, <#= t #> v2) => v1 < v2; 
        public static bool GtEq (this <#= t #> v1, <#= t #> v2) => v1 >= v2; 
        public static bool LtEq (this <#= t #> v1, <#= t #> v2) => v1 <= v2; 
        public static bool Eq (this <#= t #> v1, <#= t #> v2) => v1 == v2;
        public static bool NEq (this <#= t #> v1, <#= t #> v2) => v1 != v2; 
<# } #>

		public static bool And (this bool a, bool b) => a && b; 
		public static bool Or (this bool a, bool b) => a || b;
		public static bool NAnd (this bool a, bool b) => !(a && b);
		public static bool XOr (this bool a, bool b) => a || b && !(a && b); 
		public static bool NOr (this bool a, bool b) => !(a || b); 
		public static bool Not (this bool a) => !a;
		public static bool Eq (this bool a, bool b) => a == b;
		public static bool NEq ( this bool a, bool b) => a != b; 

<# 
foreach (var t in intTypes) { 
#>
		public static <#= t #> And (this <#= t #> a, <#= t #> b) => a & b; 
		public static <#= t #> Or (this <#= t #> a, <#= t #> b) => a | b;
		public static <#= t #> NAnd (this <#= t #> a, <#= t #> b) => ~(a & b);
		public static <#= t #> XOr (this <#= t #> a, <#= t #> b) => a | b & ~(a & b);
		public static <#= t #> NOr (this <#= t #> a, <#= t #> b) => ~(a | b); 
		public static <#= t #> Not (this <#= t #> a) => ~a;
		public static <#= t #> Abs (this <#= t #> a) => Math.Abs(a);
		public static <#= t #> DivideRoundUp (this <#= t #> a, <#= t #> b) => a / b + (a % b > 0 ? 1 : 0);
        public static bool IsEven (this <#= t #> n) => n % 2 == 0;        
        public static bool IsOdd (this <#= t #> n) => n % 2 == 1;
		public static bool IsPowerOfTwo (this <#= t #> v) => v > 0 && (v & (v - 1)) == 0;
        public static bool IsNaN (this <#= t #> n) => false;
<# } #>


<# 
foreach (var v in floatAndVectorTypes) { 
#>
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= v #> Lerp(this <#= v #> v1, <#= v #> v2, float t) => v1 + (v2 - v1) * t;
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= v #> LerpPrecise(this <#= v #> v1, <#= v #> v2, float t) => ((1 - t) * v1) + (v2 * t);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= v #> ClampLower(this <#= v #> v, <#= v #> min) => v.Max(min);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= v #> ClampUpper(this <#= v #> v, <#= v #> max) => v.Min(max);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= v #> Clamp(this <#= v #> v, <#= v #> min, <#= v #> max) => v.Min(max).Max(min);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= v #> Average(this <#= v #> v1, <#= v #> v2) => v1.Lerp(v2, 0.5f);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= v #> Barycentric(this <#= v #> v1, <#= v #> v2, <#= v #> v3, float u, float v) => v1 + (v2 - v1) * u + (v3 - v1) * v;        
<# } #>

<#
for (var i=0; i < vectorTypes.Length; ++i) {
	var v = vectorTypes[i];
	var s = i < 3 ? "float" : "double";
	var fields = (new [] { "X", "Y", "Z", "W" }).Take(i % 3 + 2);
	var dotBody = string.Join(" + ", fields.Select(f => $"v1.{f} * v2.{f}"));
	var minBody = $"new {v}(" + string.Join(", ", fields.Select(f => $"v1.{f}.Min(v2.{f})")) + ")";
	var maxBody = $"new {v}(" + string.Join(", ", fields.Select(f => $"v1.{f}.Max(v2.{f})")) + ")";
#>
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= s #> DistanceSquared(this <#= v #> v1, <#= v #> v2) => (v1 - v2).LengthSquared();
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= s #> Distance(this <#= v #> v1, <#= v #> v2) => (v1 - v2).Length();
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= s #> LengthSquared(this <#= v #> v) => v.Dot(v);
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= s #> Length(this <#= v #> v) => v.LengthSquared().Sqrt();
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= v #> Normalize(this <#= v #> v) => v / v.Length();
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= s #> Dot(this <#= v #> v1, <#= v #> v2) => <#= dotBody #>;
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= v #> Min(this <#= v #> v1, <#= v #> v2) => <#= minBody #>;
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= v #> Max(this <#= v #> v1, <#= v #> v2) => <#= maxBody #>;
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= v #> SquareRoot (this <#= v #> v) => v.Sqrt(); 
<# 
	foreach (var op in allUnaryOps) { 
		var opBody = string.Join(", ", fields.Select(f => $"v.{f}.{op}()"));
#>
		[MethodImpl(MethodImplOptions.AggressiveInlining)] public static <#= v #> <#= op #> (this <#= v #> v) => new <#= v #>(<#= opBody #>);
<# } #>

<# } #>

} } 
